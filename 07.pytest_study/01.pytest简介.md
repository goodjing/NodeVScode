## pytest简介
pytest是python的一种单元测试框架，与python自带的unittest测试框架类似，但是比unittest框架使用起来更简洁，效率更高。特点如下：
- 支持参数化
- 执行测试过程中可以将某些测试跳过（skip），或者对某些预期失败的case标记成失败
- 支持重复执行(rerun)失败的case
- 支持运行由nose, unittest编写的测试case
- 可生成html报告
- 方便的和持续集成工具jenkins集成
- 可支持执行部分用例
- 具有很多第三方插件，并且可以自定义扩展

## pytest安装
1. 安装pytest，`pip install -U pytest`
2. 查看安装版本，`pip show pytest`或者`pytest --version`

## pytest用例规则
- 文件名以test_*.py文件和*_test.py
- 以test_开头的函数
- 以Test开头的类，test_开头的方法，并且不能带有__init__ 方法
- 所有的包pakege必须要有__init__.py文件
- 断言使用assert

## 快速开始
### 1.简单测试函数
```python
# content of test_sample.py
def func(x):
    return x +1

def test_answer():
    assert func(3)==5

```
运行后，查看测试结果:
```
FAILED                                       [100%]
test_sample.py:7 (test_answer)
4 != 5

预期:5
实际:4
<点击以查看差异>

def test_answer():
>       assert func(3) == 5
E       assert 4 == 5
E        +  where 4 = func(3)

test_sample.py:9: AssertionError
```

### 2.简单测试类
测试用例有多个时，不适合写测试函数，可以把多个测试用例，写到一个测试类里。
```python
# test_class.py
import pytest

class TestClass:
    def test_one(self):
        x = "this"
        assert 'h' in x

    def test_two(self):
        x = "hello"
        assert hasattr(x, 'check')

if __name__ == "__main__":
    pytest.main('-q test_class.py')
    #  -q, --quiet decrease verbosity( 显示简单结果)
```
用例一测试通过，用例二测试失败。

## 前置和后置操作
1. 函数级（setup_function/teardown_function）只对函数用例生效（不在类中）
2. 模块级（setup_module/teardown_module）开始于模块始末，全局的
3. 类级（setup_class/teardown_class）只在类中前后运行一次(在类中)
4. 方法级（setup_method/teardown_method）开始于方法始末（在类中）
5. 类里面的（setup/teardown）运行在调用方法的前后 

### 函数级：setup_function/teardown_function
setup_function/teardown_function每个用例开始和结束都会调用一次
```python
import pytest


def setup_function():
    print("setup_function：每个用例开始前都会执行")


def teardown_function():
    print("teardown_function：每个用例结束后都会执行")


def test_one():
    print("正在执行----test_one")
    x = "this"
    assert 'h' in x


def test_two():
    print("正在执行----test_two")
    x = "hello"
    assert hasattr(x, 'check')


def test_three():
    print("正在执行----test_three")
    a = "hello"
    b = "hello world"
    assert a in b


if __name__ == "__main__":
    pytest.main(["-s", "test_setup_function.py"])
    # -s参数是为了显示用例的打印信息。 -q参数只显示结果，不显示过程

```
**执行顺序**
1. setup_function > 用例1 > teardown_function
2. setup_function > 用例2 > teardown_function
3. setup_function > 用例3 > teardown_function

### 模块级：setup_module/teardown_module
setup_module/teardown_module在整个.py模块开始和结束时调用一次
```python
import pytest

def setup_module():
    print("setup_module：整个.py模块只执行一次")
    print("比如：所有用例开始前只打开一次浏览器")

def teardown_module():
    print("teardown_module：整个.py模块只执行一次")
    print("比如：所有用例结束只最后关闭浏览器")

def setup_function():
    print("setup_function：每个用例开始前都会执行")

def teardown_function():
    print("teardown_function：每个用例结束前都会执行")
    
def test_one():
    print("正在执行----test_one")
    x = "this"
    assert 'h' in x

def test_two():
    print("正在执行----test_two")
    x = "hello"
    assert hasattr(x, 'check')

def test_three():
    print("正在执行----test_three")
    a = "hello"
    b = "hello world"
    assert a in b

if __name__ == "__main__":
    pytest.main(["-s", "test_setup_module.py"])
```
**执行顺序**
1. setup_module
2. 用例1 > 用例2 > 用例3
3. teardown_module

注意：setup_function/teardown_function和setup_module/teardown_module这四种方法可以任意组合，用一个和多个都可以。

### 类和方法 setup_class & setup_method
```python
import pytest

class TestCase():

    def setup(self):
        print("setup: 每个用例开始前执行")

    def teardown(self):
        print("teardown: 每个用例结束后执行")

    def setup_class(self):
        print("setup_class：所有用例执行之前")

    def teardown_class(self):
        print("teardown_class：所有用例执行之前")

    def setup_method(self):
        print("setup_method:  每个用例开始前执行")

    def teardown_method(self):
        print("teardown_method:  每个用例结束后执行")

    def test_one(self):
        print("正在执行----test_one")
        x = "this"
        assert 'h' in x

    def test_two(self):
        print("正在执行----test_two")
        x = "hello"
        assert hasattr(x, 'check')

    def test_three(self):
        print("正在执行----test_three")
        a = "hello"
        b = "hello world"
        assert a in b

if __name__ == "__main__":
    pytest.main(["-s", "test_class&method.py"])
```
**执行顺序**
```
test_fixtclass.py setup_class：所有用例执行之前
setup_method:  每个用例开始前执行
setup: 每个用例开始前执行
正在执行----test_one
teardown: 每个用例结束后执行
teardown_method:  每个用例结束后执行
setup_method:  每个用例开始前执行
setup: 每个用例开始前执行
正在执行----test_two
Fteardown: 每个用例结束后执行
teardown_method:  每个用例结束后执行
setup_method:  每个用例开始前执行
setup: 每个用例开始前执行
正在执行----test_three
teardown: 每个用例结束后执行
teardown_method:  每个用例结束后执行
teardown_class：所有用例执行之前
```
运行的优先级：
setup_class > setup_method > setup > 用例 > teardown > teardown_method > teardown_class

### 类和函数
```python
import pytest

def setup_module():
    print("setup_module：整个.py模块只执行一次")
    print("比如：所有用例开始前只打开一次浏览器")

def teardown_module():
    print("teardown_module：整个.py模块只执行一次")
    print("比如：所有用例结束只最后关闭浏览器")

def setup_function():
    print("setup_function：每个用例开始前都会执行")

def teardown_function():
    print("teardown_function：每个用例结束前都会执行")

def test_one():
    print("正在执行----test_one")
    x = "this"
    assert 'h' in x

def test_two():
    print("正在执行----test_two")
    x = "hello"
    assert hasattr(x, 'check')

class TestCase():

    def setup_class(self):
        print("setup_class：所有用例执行之前")

    def teardown_class(self):
        print("teardown_class：所有用例执行之前")

    def test_three(self):
        print("正在执行----test_three")
        x = "this"
        assert 'h' in x

    def test_four(self):
        print("正在执行----test_four")
        x = "hello"
        assert hasattr(x, 'check')

if __name__ == "__main__":
    pytest.main(["-s", "test_class&function.py"])
```
**运行结果**
```
test_fixtclass.py setup_module：整个.py模块只执行一次
比如：所有用例开始前只打开一次浏览器
setup_function：每个用例开始前都会执行
正在执行----test_one
.teardown_function：每个用例结束前都会执行
setup_function：每个用例开始前都会执行
正在执行----test_two
Fteardown_function：每个用例结束前都会执行
setup_class：所有用例执行之前
正在执行----test_three
.正在执行----test_four
Fteardown_class：所有用例执行之前
teardown_module：整个.py模块只执行一次
比如：所有用例结束只最后关闭浏览器
```
1. setup_module/teardown_module的优先级是最大
2. 函数里面用到的setup_function/teardown_function与类里面的setup_class/teardown_class互不干涉

